/*
    DEFINITIONS for CSC488S Source Language Winter 2016
*/

package compiler488.parser;

// TODO: You can add Java import statements here as necessary

/*
    SYMBOL LISTS

    CUP reserved words are case-sensitive and cannot be used as names of
    terminals or non-terminals. This list includes the following:

        action code extends import init left non nonassoc nonterminal package
        parser precedence right scan start super terminal with

*/

// Keyword terminals returned by the scanner (with no value attached):
terminal AND, OR, NOT, TRUE, FALSE;
terminal BOOLEAN, INTEGER, FUNCTION, PROCEDURE;
terminal DO, ELSE, EXIT, IF;
terminal READ, REPEAT, RETURN, NEWLINE, THEN, UNTIL;
terminal VAR, WHEN, WHILE, WITH, WRITE;

// Special-character terminals (with no value attached):
terminal L_PAREN, R_PAREN, L_SQUARE, R_SQUARE, L_CURLEY, R_CURLEY;
terminal EQUAL, GREATER, LESS, COMMA, DOT, QUESTION, COLON;
terminal PLUS, MINUS, TIMES, DIVIDE;

// Terminals returned by the scanner that carry a value of a specific Java type:
terminal String     IDENT;
terminal Integer    INTCONST;
terminal String     TEXTCONST;

/*
    To define non-terminals that return no value:

        nonterminal nameList;

    To define non-terminals that do return a value (think AST generation):

        nonterminal JavaType nameList;
*/

nonterminal program, statement, declaration, variablenames, bound, generalBound,
        scope, output, input, type, arguments, parameters, variable, expression;
        
nonterminal parameters_redir, output_redir, variablenames_redir, arguments_redir,
        input_redir, declaration_redir, statement_redir, e0, e1, e2, e3, e4, e5,
        e6, id, bound_int_redir, gebound_int_redir, exp_int_redir;
    
/*
    PLEASE NOTE: Your grammar may not use the 'precedence' feature of JCup to
    resolve the precedence of arithmetic operators.

    The two lines below must remain commented out;
*/

// precedence left PLUS, MINUS;
// precedence left TIMES, DIVIDE; // Higher precedence.

precedence nonassoc ELSE, COMMA, REPEAT, WHILE, DO, IF, RETURN, L_CURLEY, IDENT,
        READ, IF, EXIT, WRITE, R_SQUARE;

/*
    GRAMMAR SECTION
*/

// This specifies the initial symbol of the grammar.
start with program;

/*
    Notice that sometimes the action must be inside the production rule, not after
    it. This is a subtle yet significant difference from YACC. This is because the
    CUP parser is looking ahead one token. It ALWAYS reads one more token before it
    will act on the production.
 */

// The main program.
program
        ::= scope
        ;

/*****************************************************************************

  YOUR CAREFULLY CRAFTED GRAMMAR FOR THE CSC488S SOURCE LANGUAGE

    GOES HERE

****************************************************************************/

statement
        ::= statement_redir
        |   statement_redir statement
        ;

statement_redir                                 /* Makes precedence tests more readable. */
        ::= variable COLON EQUAL expression     {: System.out.println("---------"); :}
        |   IF expression THEN statement_redir
        |   IF expression THEN statement_redir ELSE statement_redir
        |   WHILE expression DO statement_redir
        |   REPEAT statement UNTIL expression
        |   EXIT
        |   EXIT INTCONST
        |   EXIT WHEN expression
        |   EXIT INTCONST WHEN expression
        |   RETURN WITH expression
        |   RETURN
        |   WRITE output
        |   READ input
        |   id
        |   id L_PAREN arguments R_PAREN
        |   scope
        ;

declaration
        ::= declaration_redir
        |   declaration_redir declaration
        ;

declaration_redir
        ::= VAR variablenames COLON type
        |   FUNCTION id COLON type scope
        |   FUNCTION id L_PAREN parameters R_PAREN COLON type scope
        |   PROCEDURE id scope
        |   PROCEDURE id L_PAREN parameters R_PAREN scope
        ;

variablenames
        ::= variablenames_redir
        |   variablenames_redir COMMA variablenames
        ;

variablenames_redir
        ::= id
        |   id L_SQUARE bound R_SQUARE
        |   id L_SQUARE bound COMMA bound R_SQUARE
        ;

/*
bound_redir
        ::= 
        |   bound
        |   bound COMMA bound
        ;
*/

bound
        ::= bound_int_redir
        |   generalBound DOT DOT generalBound
        ;

generalBound
        ::= gebound_int_redir
        |   MINUS INTCONST
        ;

scope
        ::= L_CURLEY declaration statement R_CURLEY
        |   L_CURLEY statement R_CURLEY
        |   L_CURLEY R_CURLEY
        ;

output
        ::= output_redir
        |   output_redir COMMA output
        ;

output_redir
        ::= expression
        |   TEXTCONST
        |   NEWLINE
        ;

input
        ::= input_redir
        |   input_redir COMMA input
        ;

input_redir
        ::= variable
        ;

type
        ::= INTEGER
        |   BOOLEAN
        ;

arguments
        ::= arguments_redir
        |   arguments_redir COMMA arguments
        ;

arguments_redir
        ::= expression
        ;

parameters
        ::= parameters_redir
        |   parameters_redir COMMA parameters
        ; 

parameters_redir
        ::= id COLON type
        ;

variable 
        ::= id
        |   id L_SQUARE expression R_SQUARE
        |   id L_SQUARE expression COMMA expression R_SQUARE
        ;

expression
        ::= expression OR e6        {: System.out.println("OR"); :}
        |   e6
        ;

e6
        ::= e6 AND e5               {: System.out.println("AND"); :}
        |   e5
        ;

e5
        ::= NOT e4                  {: System.out.println("NOT"); :}
        |   e4
        ;

e4
        ::= e3 EQUAL e3             {: System.out.println("EQUAL"); :}
        |   e3 NOT EQUAL e3         {: System.out.println("NOT EQUAL"); :}
        |   e3 LESS e3              {: System.out.println("LESS"); :}
        |   e3 LESS EQUAL e3        {: System.out.println("LESS EQUAL"); :}
        |   e3 GREATER e3           {: System.out.println("GREATER"); :}
        |   e3 GREATER EQUAL e3     {: System.out.println("GREATER EQUAL"); :}
        |   e3
        ;

e3
        ::= e3 PLUS e2              {: System.out.println("PLUS"); :}
        |   e3 MINUS e2             {: System.out.println("MINUS"); :}
        |   e2
        ;

e2
        ::= e2 TIMES e1             {: System.out.println("TIMES"); :}
        |   e2 DIVIDE e1            {: System.out.println("DIVIDE"); :}
        |   e1
        ;

e1
        ::= MINUS e0                {: System.out.println("UMINUS"); :}
        |   e0
        ;

e0
        ::= exp_int_redir
        |   TRUE
        |   FALSE
        |   L_PAREN expression R_PAREN
        |   variable
        |   id L_PAREN arguments R_PAREN
        |   L_PAREN expression QUESTION expression COLON expression R_PAREN
        ;

bound_int_redir
        ::= INTCONST
        ;

gebound_int_redir
        ::= INTCONST
        ;

exp_int_redir
        ::= INTCONST
        ;

id
        ::= IDENT
        ;

/*      
variablename
        ::= IDENT la_var
        ;

arrayname
        ::= IDENT la_arr
        ;

functionname
        ::= IDENT la_func
        ;

parametername
        ::= IDENT la_param
        ;

procedurename
        ::= IDENT la_proce
        ;
*/
