/*
    DEFINITIONS for CSC488S Source Language Winter 2016
*/

package compiler488.parser;

// TODO: You can add Java import statements here as necessary

/*
    SYMBOL LISTS

    CUP reserved words are case-sensitive and cannot be used as names of
    terminals or non-terminals. This list includes the following:

        action code extends import init left non nonassoc nonterminal package
        parser precedence right scan start super terminal with

*/

// Keyword terminals returned by the scanner (with no value attached):
terminal AND, OR, NOT, TRUE, FALSE;
terminal BOOLEAN, INTEGER, FUNCTION, PROCEDURE;
terminal DO, ELSE, EXIT, IF;
terminal READ, REPEAT, RETURN, NEWLINE, THEN, UNTIL;
terminal VAR, WHEN, WHILE, WITH, WRITE;

// Special-character terminals (with no value attached):
terminal L_PAREN, R_PAREN, L_SQUARE, R_SQUARE, L_CURLEY, R_CURLEY;
terminal EQUAL, GREATER, LESS, COMMA, DOT, QUESTION, COLON;
terminal PLUS, MINUS, TIMES, DIVIDE;

// Terminals returned by the scanner that carry a value of a specific Java type:
terminal String     IDENT;
terminal Integer    INTCONST;
terminal String     TEXTCONST;

/*
    To define non-terminals that return no value:

        nonterminal nameList;

    To define non-terminals that do return a value (think AST generation):

        nonterminal JavaType nameList;
*/

nonterminal program, statement, declaration, variablenames, 
		bound, generalBound, scope, output,
		input, type, arguments, parameters, 
		variable, expression, variablename, arrayname,
		functionname, parametername, procedurename, conditional;
		
nonterminal identifier, la_var, la_arr, la_func, la_param, la_proce,
		parameters_redir, output_redir, variablenames_redir, arguments_redir,
		input_redir, declaration_redir, expression_redir, statement_redir,
		id_redir, bound_redir, e0, e1, e2, e3, e4, e5, e6, id, bound_int_redir, 
		gebound_int_redir, exp_int_redir;
	
/*
    PLEASE NOTE: Your grammar may not use the 'precedence' feature of JCup to
    resolve the precedence of arithmetic operators.

    The two lines below must remain commented out;
*/

// precedence left PLUS, MINUS;
// precedence left TIMES, DIVIDE; // Higher precedence.

precedence nonassoc ELSE, COMMA, REPEAT, WHILE, IF, RETURN, L_CURLEY, IDENT,
		READ, IF, EXIT, WRITE, R_SQUARE;

/*
    GRAMMAR SECTION
*/

// This specifies the initial symbol of the grammar.
start with program;

/*
    Notice that sometimes the action must be inside the production rule, not after
    it. This is a subtle yet significant difference from YACC. This is because the
    CUP parser is looking ahead one token. It ALWAYS reads one more token before it
    will act on the production.
 */

// The main program.
program 
		::= scope
		;

/*****************************************************************************

  YOUR CAREFULLY CRAFTED GRAMMAR FOR THE CSC488S SOURCE LANGUAGE

    GOES HERE

****************************************************************************/

statement 
		::= statement_redir
		|	statement_redir statement
		;
		
statement_redir
		::= variable COLON EQUAL expression
		|	IF expression THEN statement
		|	IF expression THEN statement ELSE statement
		|	WHILE expression DO statement
		|	REPEAT statement UNTIL expression
		| 	EXIT
		|	EXIT WHEN expression
		|	EXIT INTCONST WHEN expression
		|	RETURN WITH expression
		|	RETURN
		|	WRITE output
		|	READ input
		|	id
		|	id L_PAREN arguments R_PAREN
		|	scope
		;

declaration 
		::= declaration_redir
		| 	declaration_redir declaration
		;
		
declaration_redir
		::= VAR variablenames COLON type
		| 	FUNCTION id COLON type scope
		| 	FUNCTION id L_PAREN parameters R_PAREN COLON type scope
		;

variablenames 
		::= variablenames_redir
		|	variablenames_redir COMMA variablenames
		;
		
variablenames_redir
		::= id
		| 	id L_SQUARE bound_redir R_SQUARE
//		| 	id L_SQUARE bound COMMA bound R_SQUARE
		;
		
bound_redir
		::= 
		|	bound
		|	bound COMMA bound
		;

bound 
		::= bound_int_redir
		| 	generalBound DOT DOT generalBound
		;

generalBound 
		::= gebound_int_redir
		| 	MINUS INTCONST
		;
		
scope 
		::= L_CURLEY declaration statement R_CURLEY
		| 	L_CURLEY statement R_CURLEY 
		| 	L_CURLEY R_CURLEY
		;

output 
		::= output_redir
		| 	output_redir COMMA output
		;

output_redir
		::= expression
		|	TEXTCONST
		|	NEWLINE
		;

input 
		::= input_redir
		| 	input_redir COMMA input
		;
		
input_redir
		::= variable
		;

type 
		::= INTEGER
		| 	BOOLEAN
		;
	   
arguments 
		::= arguments_redir
		| 	arguments_redir COMMA arguments
		;
		
arguments_redir
		::= expression
		;
	   
parameters 
		::= parameters_redir
		| 	parameters_redir COMMA parameters
		; 
		
parameters_redir
		::= id COLON type
		;
			 
variable 
		::= variablenames
		| 	id L_SQUARE expression R_SQUARE
		| 	id L_SQUARE expression COMMA expression R_SQUARE
		;
		
expression
		::= expression OR e6
		|	e6
		;
		
e6
		::= e6 AND e5
		|	e5
		;
		
e5
		::= NOT e4
		|	e4
		;
		
e4
		::= e3 EQUAL e3
		|	e3 NOT EQUAL e3
		|	e3 LESS e3
		|	e3 LESS EQUAL e3
		|	e3 GREATER e3
		|	e3 GREATER EQUAL e3
		|	e3
		;
		
e3
		::= e3 PLUS e2
		|	e3 MINUS e2
		|	e2
		;
		
e2 
		::= e2 TIMES e1
		|	e2 DIVIDE e1
		|	e1
		;
		
e1
		::= MINUS e0
		|	e0
		;
		
e0
		::= L_PAREN expression R_PAREN
		|	exp_int_redir
		|	TRUE
		|	FALSE
		|	id
		|	IDENT L_PAREN arguments R_PAREN
		|	L_PAREN expression QUESTION expression COLON expression R_PAREN
		;

bound_int_redir 
		::= INTCONST R_SQUARE
		;
		
gebound_int_redir
		::= INTCONST DOT
		;
		
exp_int_redir
		::= INTCONST
		;

id
		::= IDENT
		;

/*		
variablename 
		::=	IDENT la_var
		;
		
arrayname 
		::= IDENT la_arr
		;
		
functionname 
		::= IDENT la_func
		;
		
parametername 
		::= IDENT la_param
		;
		
procedurename 
		::= IDENT la_proce
		;
*/		
