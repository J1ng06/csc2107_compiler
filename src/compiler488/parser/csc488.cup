/*
    DEFINITIONS for CSC488S Source Language Winter 2016
*/

package compiler488.parser;

// TODO: You can add Java import statements here as necessary

/*
    SYMBOL LISTS

    CUP reserved words are case-sensitive and cannot be used as names of
    terminals or non-terminals. This list includes the following:

        action code extends import init left non nonassoc nonterminal package
        parser precedence right scan start super terminal with

*/

// Keyword terminals returned by the scanner (with no value attached):
terminal AND, OR, NOT, TRUE, FALSE;
terminal BOOLEAN, INTEGER, FUNCTION, PROCEDURE;
terminal DO, ELSE, EXIT, IF;
terminal READ, REPEAT, RETURN, NEWLINE, THEN, UNTIL;
terminal VAR, WHEN, WHILE, WITH, WRITE;

// Special-character terminals (with no value attached):
terminal L_PAREN, R_PAREN, L_SQUARE, R_SQUARE, L_CURLEY, R_CURLEY;
terminal EQUAL, GREATER, LESS, COMMA, DOT, QUESTION, COLON;
terminal PLUS, MINUS, TIMES, DIVIDE;

// Terminals returned by the scanner that carry a value of a specific Java type:
terminal String     IDENT;
terminal Integer    INTCONST;
terminal String     TEXTCONST;

/*
    To define non-terminals that return no value:

        nonterminal nameList;

    To define non-terminals that do return a value (think AST generation):

        nonterminal JavaType nameList;
*/

nonterminal program, statement, declaration, variablenames, 
		bound, generalBound, scope, output,
		input, type, arguments, parameters, 
		variable, expression, variablename, arrayname,
		functionname, parametername, procedurename;

/*
    PLEASE NOTE: Your grammar may not use the 'precedence' feature of JCup to
    resolve the precedence of arithmetic operators.

    The two lines below must remain commented out;
*/

// precedence left PLUS, MINUS;
// precedence left TIMES, DIVIDE; // Higher precedence.

/*
    GRAMMAR SECTION
*/

// This specifies the initial symbol of the grammar.
start with program;

/*
    Notice that sometimes the action must be inside the production rule, not after
    it. This is a subtle yet significant difference from YACC. This is because the
    CUP parser is looking ahead one token. It ALWAYS reads one more token before it
    will act on the production.
 */

// The main program.
program ::= scope;

/*****************************************************************************

  YOUR CAREFULLY CRAFTED GRAMMAR FOR THE CSC488S SOURCE LANGUAGE

    GOES HERE

****************************************************************************/
scope ::= L_CURLEY declaration statement R_CURLEY
		| L_CURLEY statement R_CURLEY 
		| L_CURLEY R_CURLEY;

statement ::= variable COLON EQUAL expression
		| EXIT;

declaration ::= VAR variablenames COLON type
		| FUNCTION functionname COLON type scope
		| FUNCTION functionname L_PAREN parameters R_PAREN COLON type scope
		| declaration declaration;

variablenames ::= variablename
		| variablename L_SQUARE bound R_SQUARE
		| variablename L_SQUARE bound COMMA bound R_SQUARE
		| variablenames COMMA variablenames;

bound ::= INTEGER
		| generalBound DOT DOT generalBound;

generalBound ::= INTEGER
		| MINUS INTEGER;

output ::= expression
		| TEXTCONST
		| NEWLINE
		| output COMMA output;

input ::= variable
		| input COMMA input;

type ::= INTEGER
		| BOOLEAN;
	   
arguments ::= expression
		| arguments COMMA arguments;
	   
parameters ::= parametername COLON type
		| parameters COMMA parameters; 
			 
variable ::= variablenames
		| arrayname L_SQUARE expression R_SQUARE
		| arrayname L_SQUARE expression COMMA expression R_SQUARE;

expression ::= INTEGER
		| MINUS expression
		| expression PLUS expression
		| expression MINUS expression
		| expression TIMES expression
		| expression DIVIDE expression
		| TRUE
		| FALSE
		| NOT expression
		| expression AND expression
		| expression OR expression
		| expression EQUAL expression
		| expression NOT EQUAL expression
		| expression LESS expression
		| expression LESS EQUAL expression
		| expression GREATER expression
		| expression GREATER EQUAL expression
		| L_PAREN expression R_PAREN
		| L_PAREN expression QUESTION expression COLON expression R_PAREN
		| variable
		| functionname
		| functionname L_PAREN arguments R_PAREN
		| parametername;

variablename ::= IDENT;
arrayname ::= IDENT;
functionname ::= IDENT;
parametername ::= IDENT;
procedurename ::= IDENT;
